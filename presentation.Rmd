---
title: Adopting open source practices for better science
author: |
  Pierce Edmiston  
  <pedmiston@wisc.edu>  
  [sapir.psych.wisc.edu](http://sapir.psych.wisc.edu)  
  [github.com/pedmiston](https://github.com/pedmiston)
output:
  xaringan::moon_reader:
    css: ["default", "static/font.css"]
---

# Outline

Open source practices that make for more reproducible science:

1. Version control
2. Dynamic documents
3. Building from source

Conclusion: It's worth it!

```{r, include=FALSE}
library(knitr)
opts_chunk$set(echo = FALSE, message = FALSE)
source("presentation.R")
```

---
# Why I care about reproducibility

1. I want my research to be reproducible.
2. I want to attract collaborators.

---
# The reproducibility crisis

<small>Open Science Collaboration. (2015). Estimating the reproducibility of psychological science. _Science_.</small>

```{r reproducibility-crisis}
img("refs/osc_2015_science/fig3.png", draw = TRUE)
```

---
# Why isn't psychological research more reproducible?

- Simmons, Nelson, & Simonsohn. (2011). False-positive psychology: undisclosed flexibility in data collection and analysis allows presenting anything as significant. _Psychological Science_.
- Gelman & Loken (2013). The garden of forking paths: Why multiple comparisons can be a problem, even when there is no “fishing expedition” or “p-hacking” and the research hypothesis was posited ahead of time. Unpublished manuscript.
- Palmeri, K. (2016). Psychology is in crisis over whether it's in crisis. _WIRED_.
- Ioannidis, J. (2005). Why most published research findings are false. _PLOS Medicine_.

---
# Why open source is the answer

Compare the following goals of reproducibility in science and in open source:

> My collaborators should be able to reproduce my research.  
> Anyone should be able to use and contribute to this project.

---
# Open source science

```{r open-source-science}
DiagrammeR::grViz("
digraph {
  rankdir = LR;
  node[shape = none, fontname = Helvetica];
  confidence -> collaboration;
  confidence[label = 'Confidence'];
  collaboration[label = 'Collaboration'];
}", height = 200)
```

---
# Version control

```{r, fig.width=12}
grid.arrange(img("undo-button"), img("wiki-revisions"), img("git-log"), nrow = 1)
```

---
# Pick your poison

- **git**
- mercurial
- subversion

---
# Tools for climbing

```{r}
img("climbing-tools", ".jpg", draw = TRUE)
```

???

There are a number of ways to think about version control. One way is to think about it as a safety net, that no matter what you do, you can always roll back to what it was before. This is the power of the "undo" button. However, this doesn't really get at why I think version control is such a powerful tool. A better analogy is to think about version control as a tool for climbing. The picture is of tools used by rock climbers called "nuts" that you jam into a crack in the rock, and then you can use it as a hold. This is how I think about version control. It definitely has the effect of keeping you safer, but it also allows you to climb in places you otherwise wouldn't be able to.

---
# Conquer clutter

```{r}
img("cluttered-folder", draw = TRUE)
```

---
# Forks and branches

```{r}
DiagrammeR::grViz("
digraph {
  rankdir = LR;
  bgcolor = transparent;
  node[label = ''; style = 'filled'; fillcolor = '#8DA0CB'];

  t2;

  b0 -> b1 -> b2 -> b3[style = invis];
  m0 -> m1 -> m2 -> m3;
  t0 -> t1 -> t2[style = invis];

  m1 -> t2[constraint = false];
  m2 -> b3[constraint = false];

  b0, b1, b2, t0, t1[style = invis];
}", height = 200)
```

---
# Submodules

    parent_repo/
    ├── child_repo_1  # submodule 1
    └── child_repo_2  # submodule 2

---
# Submodules

    talk or publication/
    ├── research_project_1
    └── research_project_2

???

For example, say I'm going to give a talk or write a publication that uses results from one or more ongoing research projects. With submodules I can separate the stuff that's specific to this particular talk or publication from the stuff that's relevant the the ongoing research project. For example, my stats and figures need to conform to particular standards. With submodules I can do this while leaving the underlying research project unchanged.

---
# Submodules

    meta-analysis/
    ├── research_project_1
    ├── ...
    └── research_project_n

???

Another example, one that I don't think anyone is doing, is to think about meta-analyses conducted with many research projects included as submodules. This keeps the meta-analyses linked to the research projects so that they can be updated as needed, and also allows for meta-analysis across the raw data--something that is almost impossible to do.

---
# Submodules

    project/
    ├── *web-app*  -> also installed on web server
    ├── *psychopy* -> also installed on lab computers
    ├── *r-pkg*    -> installed by anyone who wants the data
    ├── conference
    └── journal

???

A final example is one where submodules can help unite the many different parts of a research project. This is an example from my own research. We did a large scale online experiment where people played a version of the children's game of telephone online. This project had a number of parts to it, including the source code for building the web app, and some additional experiments that we ran not online but in our research lab. Finally, I like to make it so that people can install the data from my published work as an R package, so that's included as a submodule as well so that people can get the data without also getting the webserver. With submodules I can keep all of this linked, so that I can submit to a conference with a particular version of the web-app and some data and analyses included.

---
# Version control's dirty little secret

It only really works on plaintext files.

```{r}
img("excel-panic", draw = TRUE)
```

---
# Dynamic documents

- Origins: DRY, Literate Programming
- Examples: Sphinx, Jupyter, Knitr

---
# Don't Repeat Yourself (DRY)

> Every piece of knowledge must have a single, unambiguous, authoritative representation within a system.

- Hunt & Thomas, 1999, _The pragmatic programmer_. [wiki](https://en.wikipedia.org/wiki/The_Pragmatic_Programmer).

---
# Literate programming (LP)

Knuth, Donald E. (1983). _Literate programming_. [wiki](https://en.wikipedia.org/wiki/Literate_programming).

* Intermingle prose and code for better understanding of the program.
* The explanation of a program does not need to resemble the program structure.

---
# Sphinx

## Python Documentation Generation

* Python standard library: [json](https://docs.python.org/3/library/json.html)
* Third party packages: [requests](http://docs.python-requests.org/en/master/api/#requests.request)

---
# Project Jupyter

```{r}
img("jupyter-preview", draw = TRUE)
```

---
# Knitr

## Elegant, flexible and fast dynamic report generation with R

Participants in condition A outperformed participants in condition B, `report_model_results(mod, param = "condition")`.

---
# Knitr

```{r}
grid.arrange(img("knitr-source"), img("knitr-output"), nrow = 1)
```

---
# Dynamic documents in research and education

- Handouts for meetings
- Statistics homework
- Supplemental materials
- Conference proceedings
- Entire manuscripts

---
# Building from source

**What does it mean to be able to reproduce someone's published research?**  
To be able to build the published paper without the original data.

---
# Virtual environments

- Enthought
- Anaconda

---
# Cloud computing

- Amazon Web Services
- Open Stack

---
# Examples

## Kaggle data

---
# Does it work?

---
# Cultural ratchets

---
# Adoption open source practices for better science

Pierce Edmiston  
<pedmiston@wisc.edu>  
[sapir.psych.wisc.edu](http://sapir.psych.wisc.edu)  
[github.com/pedmiston](https://github.com/pedmiston)
